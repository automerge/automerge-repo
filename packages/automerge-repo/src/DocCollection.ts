import EventEmitter from "eventemitter3"
import { v4 as uuid } from "uuid"
import { DocHandle, DocHandleOptions } from "./DocHandle.js"
import { type DocumentId } from "./types.js"
import { type SharePolicy } from "./Repo.js"

/**
 * A DocCollection is a collection of DocHandles. It supports creating new documents and finding
 * documents by ID.
 * */
export class DocCollection extends EventEmitter<DocCollectionEvents> {
  #handleCache: Record<DocumentId, DocHandle<any>> = {}

  /** By default, we share generously with all peers. */
  sharePolicy: SharePolicy = async () => true

  constructor() {
    super()
  }

  /** Returns an existing handle if we have it; creates one otherwise. */
  #getHandle<T>(
    /** The documentId of the handle to look up or create */
    documentId: DocumentId,

    opts?: DocHandleOptions<T>,
  ) {
    // If we have the handle cached, return it
    if (this.#handleCache[documentId]) return this.#handleCache[documentId]

    // If not, create a new handle, cache it, and return it
    const handle = new DocHandle<T>(documentId, opts)
    this.#handleCache[documentId] = handle
    return handle
  }

  /** Returns all the handles we have cached. */
  get handles() {
    return this.#handleCache
  }

  /**
   * Creates a new document and returns a handle to it. The initial value of the document is
   * an empty object `{}`. Its documentId is generated by the system. we emit a `document` event
   * to advertise interest in the document.
   *
   * @param {Object} opts - options
   * @param {DocumentId} [opts.documentId] - a unique identifier for the newly created document. if not specified, one will be generated randomly.
   * @param {T & object} [opts.schema] - the initial value of this document.
   *   This is useful if the document must have some fixed schema. The document
   *   will be initialized so that, if another `Repo` calls `create` with the same
   *   `schema` and `documentId`, updates to fields within the `schema` can be
   *   merged. See https://automerge.org/docs/cookbook/modeling-data/#setting-up-an-initial-document-structure.
   */
  create<T>(opts?: {
    schema?: T & object
    documentId?: DocumentId
  }): DocHandle<T> {
    const documentId = opts?.documentId ?? (uuid() as DocumentId)
    const schema = opts?.schema
    const handle = this.#getHandle<T>(documentId, {
      isNew: true,
      schema,
    }) as DocHandle<T>
    this.emit("document", { handle })
    return handle
  }

  /**
   * Retrieves a document by id. It gets data from the local system, but also emits a `document`
   * event to advertise interest in the document.
   */
  find<T>(
    /** The documentId of the handle to retrieve */
    documentId: DocumentId
  ): DocHandle<T> {
    // TODO: we want a way to make sure we don't yield intermediate document states during initial synchronization

    // If we already have a handle, return it
    if (this.#handleCache[documentId])
      return this.#handleCache[documentId] as DocHandle<T>

    // Otherwise, create a new handle
    const handle = this.#getHandle<T>(documentId, {
      isNew: false,
    }) as DocHandle<T>

    // we don't directly initialize a value here because the StorageSubsystem and Synchronizers go
    // and get the data asynchronously and block on read instead of on create

    // emit a document event to advertise interest in this document
    this.emit("document", { handle })

    return handle
  }

  delete(
    /** The documentId of the handle to delete */
    documentId: DocumentId
  ) {
    const handle = this.#getHandle(documentId, { isNew: false })
    handle.delete()

    delete this.#handleCache[documentId]
    this.emit("delete-document", { documentId })
  }
}

// events & payloads
interface DocCollectionEvents {
  document: (arg: DocumentPayload) => void
  "delete-document": (arg: DeleteDocumentPayload) => void
}

interface DocumentPayload {
  handle: DocHandle<any>
}

interface DeleteDocumentPayload {
  documentId: DocumentId
}
